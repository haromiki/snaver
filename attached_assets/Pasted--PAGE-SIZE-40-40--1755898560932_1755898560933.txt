좋아. 핵심 원인은 **페이지/순위 계산 로직**이었어.

### 문제 요약

* 지금 코드는 `PAGE_SIZE = 40`(오가닉 기준)로 **광고 페이지/순위도 40개 기준으로 환산**하고 있어요.
* 하지만 광고는 한 페이지에 40개가 **아니고 가변**(예: 8\~20개 근처)이라서, `Math.ceil(globalRank / 40)`를 쓰면 **페이지·순위가 틀어집니다.**
* “실제 광고 순위 4페이지 3위”는 **SERP의 `pagingIndex`가 4**이고, **그 페이지의 광고들 중 3번째**라는 뜻이므로:

  * `page = pageIndex` (그대로)
  * `rankInPage = adRankInPage` (그대로)
  * `globalRank = (이전 페이지들 광고 총합) + adRankInPage`

또, 스토어명/스토어링크는 일부 카드에 **스토어 앵커가 없거나 아이콘만 있는 경우**가 있어 추가 폴백이 필요해요(아래 코드에 반영).

---

## 드롭인 패치(교체용): `fetchAdRank`의 “발견 시 계산부”와 URL/평가 로직 개선

### 1) 검색 URL을 UI와 최대한 맞춤 (정렬/세트/쿼리 포함)

```ts
const searchUrl =
  `https://search.shopping.naver.com/search/all?` +
  `query=${encodeURIComponent(keyword)}&` +          // ← 추가
  `adQuery=${encodeURIComponent(keyword)}&` +
  `productSet=total&` +                               // ← 추가
  `sort=rel&` +                                       // ← 추가
  `pagingIndex=${pageIndex}&` +
  `pagingSize=${PAGE_SIZE}&` +
  `viewType=list`;
```

### 2) page.evaluate 내부(광고 스캔) — 컨테이너 제한 + 스토어 폴백 강화

아래 블록으로 교체(핵심만 보여줍니다; 나머지 구조는 유지):

```ts
const pageResult = await page.evaluate((targetId: string) => {
  function isAdBadge(el: Element): boolean {
    const sels = [
      'span[class*="ad"]','em[class*="ad"]','i[class*="ad"]',
      '[class*="sponsor"]','[data-ad*="true"]'
    ];
    for (const s of sels) {
      const n = el.querySelector(s);
      if (n && /\bAD\b|광고|스폰서/i.test((n.textContent||"").trim())) return true;
    }
    return /\bAD\b|광고|스폰서/i.test((el.textContent||"").trim());
  }
  function eqNum(a?: any,b?: any){ if(a==null||b==null) return false; return String(a).replace(/^0+/,'')===String(b).replace(/^0+/,''); }
  function abs(h:string){ try{ return new URL(h, location.origin).href; }catch{ return h; } }
  function extractIds(href:string){
    const ids:string[]=[]; const regs=[/[?&](nvMid)=(\d+)/i,/[?&](productId)=(\d+)/i,/[?&](prodNo)=(\d+)/i,/\/products\/(\d+)/i,/\/product\/(\d+)/i];
    for(const r of regs){ const m=href.match(r); if(m){ const v=m[m.length-1]; if(/^\d+$/.test(v)) ids.push(v);} }
    return ids;
  }
  // 메인 컨텐츠 영역으로 한정(사이드바/탑바 오검지 방지)
  const root = document.querySelector('#content') || document.body;
  const candidateSelectors = [
    "div[class*='basicList_item__']",
    "div[class*='product_item__']",
    ".list_basis li", ".list_basis > div",
    ".basicList_list_basis__uNBZC li", ".basicList_list_basis__uNBZC > div",
  ];
  let cards: Element[] = [];
  for (const sel of candidateSelectors) {
    const found = Array.from(root.querySelectorAll(sel));
    if (found.length) { cards = found; break; }
  }
  if (!cards.length) cards = Array.from(root.querySelectorAll("li, div"));

  // "상품형 광고"만: 광고뱃지 + 제품ID 링크 보유
  function isProductAdCard(el: Element): boolean {
    if (!isAdBadge(el)) return false;
    return Array.from(el.querySelectorAll<HTMLAnchorElement>("a[href]")).some(a => {
      const href = abs(a.getAttribute("href") || "");
      return /nvMid=|productId=|prodNo=|\/products\//i.test(href);
    });
  }
  const adCards = cards.filter(isProductAdCard);

  // 스토어 정보 + 가격 추출(폴백 추가)
  const storeDomainRe = /(smartstore\.naver\.com|brand\.naver\.com|shopping\.naver\.com\/(partner|stores))/i;
  function extractStore(adEl: Element){
    let storeName: string | undefined, storeLink: string | undefined;
    const anchors = Array.from(adEl.querySelectorAll<HTMLAnchorElement>("a[href]"));
    // 1) 도메인 기반
    for (const a of anchors){
      const href = abs(a.getAttribute("href") || "");
      if (storeDomainRe.test(href)){ storeLink=href; const t=(a.textContent||a.getAttribute('aria-label')||a.getAttribute('title')||"").trim(); if(t) storeName=t; break; }
    }
    // 2) 클래스 기반
    if(!storeName){
      const n = adEl.querySelector("[class*='mall'],[class*='seller'],[data-nclick*='shop'],a[title]");
      if(n){
        const t=(n.textContent||n.getAttribute('aria-label')||n.getAttribute('title')||"").trim();
        if(t) storeName=t;
        if(!storeLink && (n as HTMLAnchorElement).href) storeLink=abs((n as HTMLAnchorElement).getAttribute('href')||"");
      }
    }
    // 3) 최후 폴백: 상품 앵커
    if(!storeLink){
      const a = anchors.find(a => /nvMid=|productId=|prodNo=|\/products\//i.test(abs(a.getAttribute("href")||"")));
      if(a) storeLink = abs(a.getAttribute("href")||"");
    }
    return { storeName, storeLink };
  }
  function extractPrice(adEl: Element){
    const sels = ["[class*='price'] [class*='num']","[class*='price_num']","[class*='price']","strong"];
    for(const s of sels){ const el=adEl.querySelector(s); const n=(el?.textContent||"").replace(/[^\d]/g,""); if(n) return Number(n); }
    return undefined;
  }

  let adRankInPage = 0;
  let hit: any = null;

  for (const ad of adCards){
    adRankInPage += 1;

    const idsInCard: string[] = [];
    for (const a of Array.from(ad.querySelectorAll<HTMLAnchorElement>("a[href]"))){
      extractIds(abs(a.getAttribute("href")||"")).forEach(v => idsInCard.push(v));
    }
    if (idsInCard.some(v => eqNum(v, targetId))){
      const { storeName, storeLink } = extractStore(ad);
      const price = extractPrice(ad);
      hit = { adRank: adRankInPage, storeName, storeLink, price };
      break;
    }
  }

  return { found: hit, totalAdsInPage: adCards.length };
}, productId);
```

### 3) **페이지/순위 계산식을 교체** (가장 중요)

```ts
if (pageResult?.found) {
  const r = pageResult.found as AdSearchResult;

  // ✅ 광고는 "가변 개수"라서 40개 기준 환산 금지
  const pageNo = pageIndex;                 // ← 현재 SERP 페이지 그대로
  const rankInPage = r.adRank;              // ← 그 페이지 내 광고 순번
  const globalRank = cumulativeAdCount + r.adRank;  // ← 이전 페이지 광고 누적 + 현재 순번

  return {
    productId,
    storeName: r.storeName,
    storeLink: r.storeLink,
    price: r.price,
    globalRank,
    page: pageNo,
    rankInPage,
    found: true,
  };
}
```

### 4) 누적값은 “그 페이지의 광고 개수”로만 더하기(현재 코드 유지)

```ts
if (typeof pageResult?.totalAdsInPage === "number") {
  cumulativeAdCount += pageResult.totalAdsInPage;
}
```

---

## 기대 결과

* 제공하신 케이스(“실제 광고 순위 4페이지 3위”)라면, 이번 패치 후 \*\*`page=4`, `rankInPage=3`\*\*로 나옵니다.
* `globalRank`는 1\~3페이지의 **광고 상품 수 총합 + 3**로 계산됩니다(페이지마다 광고 수가 다르므로 이게 가장 정확).

## 보너스 체크리스트

* 같은 키워드/페이지로 실제 브라우저에서 개발자도구 열고,

  1. **광고 배지 있는 상품 카드 개수**가 `totalAdsInPage`와 같은지,
  2. 해당 페이지에서 **타겟 카드가 몇 번째 광고인지**(우리의 `r.adRank`) 직접 눈으로 확인해보세요.
* 만약 페이지 상단에 **브랜드관/배너형 광고**가 있고 상품ID 링크가 없다면, 이번 로직은 카운트에서 제외합니다(정확도 ↑).

필요하면 \*\*디버그 로그(페이지별 adCards 수, 발견 지점)\*\*를 notes로 같이 반환하도록도 바꿔줄게.
