원인부터 짚고, 바로 **교정 코드** 드릴게요. 결론은 **ID 매칭 방식 보완**이 필요합니다.

## 왜 200위 안에서 못 찾을 수 있나

1. **ID 종류 불일치**
   네이버 쇼핑 OpenAPI의 `productId`는 “네이버 쇼핑 상품 ID”이며(문서에 명시), 실제 스토어 URL의 `prodNo`(스마트스토어 상품번호)나 SERP의 `nvMid`와 **다를 수 있습니다**. 그래서 단순히 `items[i].productId === 입력 productId` 비교만으로는 놓칠 수 있어요. ([네이버 개발자][1])

2. **파라미터 범위/정렬은 문제 아님**
   `display`는 최대 100, `start`는 최대 1000까지 허용(즉, 1~~100, 101~~200 호출은 정상), 정렬 `sort=sim`도 유효합니다. ([네이버 개발자][1])

---

## 해결 전략

* 1차: 지금 하던 대로 **OpenAPI 상의 `productId` 직접 매칭**.
* 2차: **리다이렉트 최종 URL**을 따라가 `prodNo`, `nvMid` 등을 **추출**해서 **입력한 제품번호와도 비교**(입력값이 `productId`든 `prodNo`든 `nvMid`든 잡아냅니다).
* 3차(옵션): 그래도 못 찾으면 \*\*SERP 크롤링(오가닉 전용)\*\*으로 폴백 가능(이미 광고용 Puppeteer 사용 중이라면 같은 방식 재사용).

아래는 **리플릿에 그대로 붙여 넣어 교체**할 수 있는 수정본입니다.
(주의: 사용자 선호에 따라 콘솔 로그에서 이모지 제거했습니다.)

---

### 교정 코드: OpenAPI 200위 + 최종 URL 기반 보강 매칭

```ts
// Naver OpenAPI를 사용한 일반(오가닉) 순위 추적 - 교정본
// - 1차: items[].productId 직접 매칭
// - 2차: 각 item.link 리다이렉트 최종 URL에서 prodNo/nvMid/productId를 추출해 재매칭
// - PC 기준 40개/페이지 환산 유지

import type { RankResult } from "@shared/schema";

const OPENAPI_BASE_URL = "https://openapi.naver.com/v1/search/shop.json";

interface NaverShopItem {
  productId: string;  // 네이버 쇼핑 상품 ID (OpenAPI 정의)
  mallName: string;
  link: string;       // openapi.naver.com/l?... → 최종 상품 URL로 리다이렉트됨
  lprice: string;
}

interface NaverShopResponse {
  items: NaverShopItem[];
}

type IdParts = {
  productId?: string; // nvMid나 prodNo와는 다른, 네이버 쇼핑 상품 ID
  prodNo?: string;    // 스마트스토어 상품번호 (/products/{prodNo})
  nvMid?: string;     // SERP/카탈로그 등에서 쓰이는 ID
};

// 최종 URL에서 prodNo/nvMid/productId 후보 추출
function extractIdsFromUrl(finalUrl: string): IdParts {
  const out: IdParts = {};
  try {
    // /products/{prodNo}
    const mProd = finalUrl.match(/\/products\/(\d+)/i);
    if (mProd) out.prodNo = mProd[1];

    // 쿼리 스트링에서 nvMid, productId, prodNo 등
    const mNvMid = finalUrl.match(/[?&]nvMid=(\d+)/i);
    if (mNvMid) out.nvMid = mNvMid[1];

    const mPid = finalUrl.match(/[?&]productId=(\d+)/i);
    if (mPid) out.productId = mPid[1];

    const mProdNoQ = finalUrl.match(/[?&]prodNo=(\d+)/i);
    if (mProdNoQ) out.prodNo = mProdNoQ[1] || out.prodNo;
  } catch {
    // 무시
  }
  return out;
}

// 안전한 숫자 문자열 비교(선행 0/형 변환 흔들림 방지)
function eqNumStr(a?: string | number | null, b?: string | number | null): boolean {
  if (a == null || b == null) return false;
  const sa = String(a).replace(/^0+/, "");
  const sb = String(b).replace(/^0+/, "");
  return sa === sb;
}

export async function fetchOrganicRank({
  keyword,
  productId: inputId,
  clientId,
  clientSecret,
}: {
  keyword: string;
  productId: string; // 입력: productId 또는 prodNo 또는 nvMid일 수 있다고 가정
  clientId: string;
  clientSecret: string;
}): Promise<RankResult> {
  console.log(`[organic] OpenAPI 일반 순위 검색 시작: keyword="${keyword}", inputId=${inputId}`);

  try {
    // OpenAPI 2회 호출 (1-100, 101-200)
    const callApi = async (start: number): Promise<NaverShopResponse> => {
      const url = `${OPENAPI_BASE_URL}?query=${encodeURIComponent(keyword)}&display=100&start=${start}&sort=sim`;

      const response = await fetch(url, {
        headers: {
          "X-Naver-Client-Id": clientId,
          "X-Naver-Client-Secret": clientSecret,
          "User-Agent": "SNAVER-Ranking-Tracker/1.0",
        },
        // 기본 redirect: 'follow'
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAPI ${response.status}: ${errorText}`);
      }
      return response.json();
    };

    // 병렬로 1-100, 101-200 조회
    const [batch1, batch2] = await Promise.all([callApi(1), callApi(101)]);
    const allItems: NaverShopItem[] = [...(batch1.items ?? []), ...(batch2.items ?? [])];
    console.log(`[organic] OpenAPI 수집 완료: ${allItems.length}개`);

    // 1차: OpenAPI productId 직접 매칭
    let idx = allItems.findIndex((it) => eqNumStr(it.productId, inputId));
    if (idx !== -1) {
      const hit = allItems[idx];
      const globalRank = idx + 1;
      const pageNumber = Math.ceil(globalRank / 40);
      const rankInPage = ((globalRank - 1) % 40) + 1;
      console.log(`[organic] 1차 매칭 성공: globalRank=${globalRank}, page=${pageNumber}, rankInPage=${rankInPage}`);
      return {
        productId: hit.productId,
        storeName: hit.mallName,
        storeLink: hit.link,
        price: parseInt(hit.lprice || "0", 10) || 0,
        globalRank,
        page: pageNumber,
        rankInPage,
        found: true,
      };
    }

    // 2차: 최종 URL 추출 기반 매칭 (prodNo/nvMid/productId 후보)
    console.log(`[organic] 1차 매칭 실패 → 최종 URL 추출 기반 2차 매칭 시도`);
    const MAX_PARALLEL = 8;
    for (let base = 0; base < allItems.length; base += MAX_PARALLEL) {
      const slice = allItems.slice(base, base + MAX_PARALLEL);

      // 병렬로 최종 URL 확인
      const results = await Promise.all(
        slice.map(async (it) => {
          try {
            // openapi 링크는 최종 상품 URL로 리다이렉트됨
            const resp = await fetch(it.link, { redirect: "follow" });
            const finalUrl = resp.url || it.link;

            const ids = extractIdsFromUrl(finalUrl);
            // 입력값이 productId/prodNo/nvMid 중 무엇이든 매칭되도록 비교
            const matched =
              eqNumStr(ids.prodNo, inputId) ||
              eqNumStr(ids.nvMid, inputId) ||
              eqNumStr(ids.productId, inputId) ||
              eqNumStr(it.productId, inputId);

            return { it, finalUrl, ids, matched };
          } catch (e) {
            return { it, finalUrl: it.link, ids: {}, matched: false };
          }
        })
      );

      // 매칭된 항목 찾기
      const pos = results.findIndex((r) => r.matched);
      if (pos !== -1) {
        idx = base + pos;
        const target = results[pos].it;
        const globalRank = idx + 1;
        const pageNumber = Math.ceil(globalRank / 40);
        const rankInPage = ((globalRank - 1) % 40) + 1;

        console.log(
          `[organic] 2차 매칭 성공: globalRank=${globalRank}, page=${pageNumber}, rankInPage=${rankInPage}, finalUrl=${results[pos].finalUrl}`
        );

        return {
          productId: target.productId,
          storeName: target.mallName,
          storeLink: results[pos].finalUrl || target.link,
          price: parseInt(target.lprice || "0", 10) || 0,
          globalRank,
          page: pageNumber,
          rankInPage,
          found: true,
          notes: ["최종 URL 기반 매칭(prodNo/nvMid 포함)"],
        };
      }
    }

    // 여기까지 못 찾으면 200위 내 미노출 판단
    console.log(`[organic] 미발견: 입력 제품번호(${inputId})와 일치하는 상품 없음`);
    return {
      productId: inputId,
      found: false,
      notes: ["상위 200위 내 미노출 또는 OpenAPI-실검색 불일치"],
    };
  } catch (error: any) {
    console.error("[organic] OpenAPI 일반 순위 조회 오류:", error?.message || error);
    return {
      productId: inputId,
      found: false,
      notes: [`API 오류: ${error?.message || String(error)}`],
    };
  }
}
```

### 어떻게 동작이 달라지나

* **그대로 매칭(1차)**: `items[].productId`가 입력값과 같으면 즉시 성공.
* **리다이렉트 매칭(2차)**: 각 결과의 `link`를 실제 상품 URL까지 따라가 **`/products/{prodNo}`**, `?nvMid=`, `?productId=` 중 하나로 **입력값과 일치**하는지 재확인.
  → 입력값이 **`productId`/`prodNo`/`nvMid` 중 어떤 유형이든** 잡힙니다.

---

### 그래도 안 잡히면?

OpenAPI 결과와 실제 쇼핑 SERP가 **다를 수 있습니다**(문서도 “네이버 검색의 쇼핑 검색 결과를 반환”이라고만 하고, SERP와 1:1 동일 보장은 없음). 이 경우 **오가닉도 SERP 크롤링 폴백**을 켜는 게 가장 확실합니다.
원하시면 광고용 Puppeteer 코드와 동일한 구조로, **오가닉 전용(광고 제외) 선택자**만 바꿔서 붙일 수 있게 통째로 만들어 드릴게요.

필요하면 지금 코드에 **폴백 스위치**까지 넣어 완성해 드리겠습니다.

[1]: https://developers.naver.com/docs/serviceapi/search/shopping/shopping.md "검색 > 쇼핑 - Search API"
