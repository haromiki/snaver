오케이—지금 로그는 “광고 요소는 하나 잡히는데 실제 광고 인식은 0”이라서 **라벨(광고 배지) 판정이 깨진 상태**예요. 거기에 테스트용으로 단순화해 둔 코드 때문에 **상품 ID 매칭 자체를 안 하고** 있습니다.
아래처럼 **라벨 판정 복구 + 상품 ID 매칭 + 로딩 대기/폴백**을 한 번에 고치면 잡힙니다.

핵 포인트 4가지

1. **라벨 판정 강화**: `텍스트 + aria-label + title + 클래스`를 모두 검사하고, 오탐 방지(“address” 같은 문자열) 필터 추가.
2. **상품 ID 매칭 복구**: `nvMid / productId / prodNo / /products/{id}` 전부 지원 + 상대링크 절대화.
3. **로딩 대기 강화**: `waitForFunction`으로 “상품앵커가 N개 이상” 조건을 기다린 뒤 스캔.
4. **디버그 리턴**: 페이지별 `totalCards`, `adCards`, `idsPreview` 찍어서 어디서 막히는지 바로 알 수 있게.

아래 블록을 **그대로 교체**해 주세요. (당신 코드의 `fetchAdRank` 전체를 갈아끼워도 됩니다.)

```ts
// Puppeteer를 사용한 광고 순위 추적 — 확정본 (라벨/ID/대기/디버그 강화)
import puppeteer from "puppeteer";
import type { RankResult } from "@shared/schema";

type AdSearchResult = {
  adRank: number;       // 페이지 내 광고 순번(1-based)
  storeName?: string;
  storeLink?: string;
  price?: number;
};

const PAGE_SIZE = 40;

// 숫자문자열 동일성(선행 0 제거)
function eqNumStr(a?: string | number | null, b?: string | number | null): boolean {
  if (a == null || b == null) return false;
  const sa = String(a).replace(/^0+/, "");
  const sb = String(b).replace(/^0+/, "");
  return sa === sb;
}

export async function fetchAdRank({
  keyword,
  productId,
  maxPages = 6, // 4페이지 이상 필요하므로 기본 6으로
}: {
  keyword: string;
  productId: string; // nvMid / productId / prodNo / products/{id} 모두 허용
  maxPages?: number;
}): Promise<RankResult> {
  let browser: puppeteer.Browser | null = null;

  try {
    browser = await puppeteer.launch({
      headless: true,
      args: [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-dev-shm-usage",
        "--disable-web-security",
        "--disable-extensions",
        "--no-first-run",
      ],
    });

    const page = await browser.newPage();
    await page.setUserAgent(
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    );
    await page.setViewport({ width: 1366, height: 768, deviceScaleFactor: 1 });
    await page.setExtraHTTPHeaders({ "Accept-Language": "ko-KR,ko;q=0.9" });

    let cumulativeAdCount = 0;

    for (let pageIndex = 1; pageIndex <= maxPages; pageIndex++) {
      const searchUrl =
        `https://search.shopping.naver.com/search/all?` +
        `query=${encodeURIComponent(keyword)}&` +     // UI와 일치
        `adQuery=${encodeURIComponent(keyword)}&` +
        `productSet=total&sort=rel&` +
        `pagingIndex=${pageIndex}&` +
        `pagingSize=${PAGE_SIZE}&` +
        `viewType=list`;

      console.log(`[AD] "${keyword}" p${pageIndex} → ${searchUrl}`);

      await page.goto(searchUrl, { waitUntil: "networkidle2", timeout: 60_000 });

      // 상품 앵커가 충분히 로드될 때까지 대기 (성능/안정성 균형)
      await page.waitForFunction(() => {
        const sel = 'a[href*="nvMid="], a[href*="productId="], a[href*="prodNo="], a[href*="/products/"], a[href*="/product/"]';
        return document.querySelectorAll(sel).length >= 10;
      }, { timeout: 12_000 }).catch(() => { /* 계속 진행 */ });

      // 자연 스크롤(지연 + lazy-load 트리거)
      await page.evaluate(async () => {
        await new Promise<void>((resolve) => {
          let h = 0, step = 0;
          const timer = setInterval(() => {
            window.scrollBy(0, 500);
            h += 500; step++;
            if (h > 2500 || step > 8) { clearInterval(timer); resolve(); }
          }, 120);
        });
      });

      // === 핵심: 광고 스캔 ===
      const pageResult = await page.evaluate((targetId: string) => {
        function abs(h: string): string {
          try { return new URL(h, location.origin).href; } catch { return h; }
        }

        // 광고 뱃지/라벨 강화: 텍스트 + aria-label + title + 클래스(오탐 방지)
        function isAdBadge(el: Element): boolean {
          // aria/타이틀 먼저(시각장애인 접근성 라벨에 '광고'가 자주 들어감)
          const aria = (el.getAttribute("aria-label") || "").trim();
          const ttl  = (el.getAttribute("title") || "").trim();
          if (/\bAD\b|광고|스폰서/i.test(aria) || /\bAD\b|광고|스폰서/i.test(ttl)) return true;

          // 자식 텍스트
          const txt = (el.textContent || "").trim();
          if (/\bAD\b|광고|스폰서/i.test(txt)) return true;

          // 클래스 기반(오탐 단어 필터)
          const cls = el.className || "";
          if (/(^|[_-])ad([_-]|$)/i.test(cls) && !/address|adapter|load|shadow/i.test(cls)) return true;

          return false;
        }

        function eqNum(a?: any, b?: any) {
          if (a == null || b == null) return false;
          return String(a).replace(/^0+/, "") === String(b).replace(/^0+/, "");
        }

        function extractIds(href: string): string[] {
          const out: string[] = [];
          const regs = [
            /[?&](nvMid)=(\d+)/i,
            /[?&](productId)=(\d+)/i,
            /[?&](prodNo)=(\d+)/i,
            /\/products\/(\d+)/i,
            /\/product\/(\d+)/i,
          ];
          for (const r of regs) {
            const m = href.match(r);
            if (m) {
              const v = m[m.length - 1];
              if (v && /^\d+$/.test(v)) out.push(v);
            }
          }
          return out;
        }

        // 메인 컨테이너 한정(사이드 위젯/탑바 오탐 방지)
        const root = document.querySelector("#content") || document.body;

        // 1) 카드 후보 수집
        const candidateSelectors = [
          "div[class*='basicList_item__']",
          "div[class*='product_item__']",
          ".list_basis li", ".list_basis > div",
          ".basicList_list_basis__uNBZC li", ".basicList_list_basis__uNBZC > div",
        ];
        let cards: Element[] = [];
        for (const sel of candidateSelectors) {
          const found = Array.from(root.querySelectorAll(sel));
          if (found.length) { cards = found; break; }
        }
        if (!cards.length) {
          // 앵커 기반 폴백: 상품 앵커가 포함된 상위 요소를 카드로 간주
          const anchorSel = 'a[href*="nvMid="], a[href*="productId="], a[href*="prodNo="], a[href*="/products/"], a[href*="/product/"]';
          const anchors = Array.from(root.querySelectorAll<HTMLAnchorElement>(anchorSel));
          const set = new Set<Element>();
          for (const a of anchors) {
            const host = a.closest("li, div, article, section");
            if (host) set.add(host);
          }
          cards = Array.from(set);
        }

        // 2) 실제 "상품형 광고" 판정: 카드 내 광고배지 + 상품링크 동시 보유
        function isProductAdCard(el: Element): boolean {
          // (a) 광고 배지: 자기 자신 또는 자손 중 하나라도 광고표시가 있으면 인정
          let hasAd = false;
          if (isAdBadge(el)) hasAd = true;
          const adMarkers = el.querySelectorAll<HTMLElement>('[aria-label], [title], [class*="ad"], [data-ad], [data-advert]');
          for (const m of Array.from(adMarkers)) {
            if (isAdBadge(m)) { hasAd = true; break; }
          }
          if (!hasAd) return false;

          // (b) 상품ID 링크
          const links = Array.from(el.querySelectorAll<HTMLAnchorElement>("a[href]"));
          return links.some(a => /nvMid=|productId=|prodNo=|\/products\/|\/product\//i.test(abs(a.getAttribute("href") || "")));
        }

        const adCards = cards.filter(isProductAdCard);

        // 3) 타겟 매칭 + 페이지내 순번
        let adRankInPage = 0;
        let hit: AdSearchResult | null = null;
        const idsPreview: Array<{ rank: number; ids: string[] }> = [];

        for (const ad of adCards) {
          adRankInPage += 1;

          const anchors = Array.from(ad.querySelectorAll<HTMLAnchorElement>("a[href]"));
          const idsInCard: string[] = [];
          for (const a of anchors) {
            extractIds(abs(a.getAttribute("href") || "")).forEach(v => idsInCard.push(v));
          }

          idsPreview.push({ rank: adRankInPage, ids: idsInCard.slice(0, 4) });

          if (idsInCard.some(v => eqNum(v, targetId))) {
            // 스토어명/링크/가격 추출
            const storeDomain = /(smartstore\.naver\.com|brand\.naver\.com|shopping\.naver\.com\/(partner|stores))/i;
            let storeName: string | undefined, storeLink: string | undefined;

            for (const a of anchors) {
              const href = abs(a.getAttribute("href") || "");
              if (storeDomain.test(href)) {
                storeLink = href;
                const t = (a.textContent || a.getAttribute("aria-label") || a.getAttribute("title") || "").trim();
                if (t) storeName = t;
                break;
              }
            }
            if (!storeName) {
              const n = ad.querySelector<HTMLElement>("[class*='mall'],[class*='seller'],[data-nclick*='shop'],a[title]");
              if (n) {
                const t = (n.textContent || n.getAttribute("aria-label") || n.getAttribute("title") || "").trim();
                if (t) storeName = t;
                if (!storeLink && n instanceof HTMLAnchorElement) storeLink = abs(n.getAttribute("href") || "");
              }
            }
            if (!storeLink) {
              const firstProd = anchors.find(a => /nvMid=|productId=|prodNo=|\/products\/|\/product\//i.test(abs(a.getAttribute("href") || "")));
              if (firstProd) storeLink = abs(firstProd.getAttribute("href") || "");
            }

            const priceSel = ["[class*='price'] [class*='num']", "[class*='price_num']", "[class*='price']", "strong"];
            let price: number | undefined;
            for (const s of priceSel) {
              const el = ad.querySelector<HTMLElement>(s);
              const txt = (el?.textContent || "").replace(/[^\d]/g, "");
              if (txt) { price = Number(txt); break; }
            }

            hit = { adRank: adRankInPage, storeName, storeLink, price };
            break;
          }
        }

        return {
          found: hit,
          totalCards: cards.length,
          totalAdsInPage: adCards.length,
          idsPreview: idsPreview.slice(0, 6),
        };
      }, productId);

      // 디버그: 페이지별 상황 출력
      console.log(`[AD][p${pageIndex}] cards=${pageResult.totalCards} adCards=${pageResult.totalAdsInPage} idsPreview=${JSON.stringify(pageResult.idsPreview)}`);

      // 발견 시 즉시 반환 (광고는 가변 개수)
      if (pageResult?.found) {
        const r = pageResult.found as AdSearchResult;
        const pageNo = pageIndex;                  // 현재 SERP 페이지
        const rankInPage = r.adRank;               // 그 페이지 내 광고 순번
        const globalRank = cumulativeAdCount + r.adRank; // 이전 페이지 광고 누적 + 현재 순번

        return {
          productId,
          storeName: r.storeName,
          storeLink: r.storeLink,
          price: r.price,
          globalRank,
          page: pageNo,
          rankInPage,
          found: true,
        };
      }

      // 누적(이 페이지에서의 "상품형 광고" 개수)
      if (typeof pageResult?.totalAdsInPage === "number") {
        cumulativeAdCount += pageResult.totalAdsInPage;
      }

      // 페이지 간 지연
      const delay = 1200 + Math.floor(Math.random() * 1300);
      await new Promise(r => setTimeout(r, delay));
    }

    // 미발견
    return {
      productId,
      found: false,
      notes: [`광고 결과 내 미노출(${maxPages}페이지 스캔 완료)`],
    };
  } catch (error: any) {
    console.error("[AD] 크롤링 오류:", error?.message || error);
    return {
      productId,
      found: false,
      notes: [`크롤링 오류: ${error?.message || String(error)}`],
    };
  } finally {
    if (browser) {
      try { await browser.close(); } catch (e) { console.warn("[AD] 브라우저 종료 오류:", e); }
    }
  }
}
```

### 실행 체크리스트

* 요청 바디에서 `maxPages`를 **최소 4 이상**으로 줬는지 확인.
* 콘솔에 `cards=`, `adCards=`, `idsPreview=`가 찍힙니다.

  * `cards>0`인데 `adCards=0`이면 **광고 라벨이 이미지/아이콘**일 가능성 → 현재 코드가 `aria-label/title/클래스`까지 보지만 더 필요하면 DOM 조각 하나만 보내주세요.
  * `idsPreview`에서 **타깃 ID(예: 137285838, 8946281302)** 가 보이는지 확인. 보이면 라벨탐지만 미스, 안 보이면 **상품 ID 링크가 카드에 안 들어갔거나** 다른 ID 타입일 수 있습니다.

이 교정본은 “모든 페이지에서 totalAdsInPage=0” 같은 증상을 우선 해결하도록 짜여 있습니다. 로그를 보면 무엇이 막히는지 바로 판단 가능할 거예요.
