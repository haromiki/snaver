오케이. 두 가지를 바로 잡아야 합니다.

1. **광고 카드 판정이 느슨해서 ‘광고 아님’을 광고로 집계** → 누적 카운트가 커져 랭킹 오차 발생
2. **스토어명/스토어링크 선택자가 부족** → 값이 빠짐

아래 **드롭인 교정본**을 그대로 붙여 넣어 교체하세요. 핵심은:

* “광고” + “상품형 광고 카드” 둘 다 만족할 때만 카운트(정확도 향상)
* 스토어명/링크를 **도메인 기반**으로 견고하게 뽑고, 안 나오면 안전한 폴백

---

### 교정본 (page.evaluate 블록만 교체)

아래의 `// 현재 페이지 광고 스캔`부터 `return {...}` 까지를 통째로 바꿔주세요.

```ts
// 현재 페이지 광고 스캔 (정확도 강화판)
const pageResult = await page.evaluate((targetId: string, PAGE_SIZE_IN: number) => {
  // 1) 광고 라벨 텍스트 확인
  function isAdBadge(el: Element): boolean {
    const labelSel = [
      'span[class*="ad"]',
      'em[class*="ad"]',
      'i[class*="ad"]',
      '[class*="sponsor"]',
      '[data-ad*="true"]',
    ];
    for (const s of labelSel) {
      const n = el.querySelector(s);
      if (n) {
        const t = (n.textContent || "").trim();
        if (/\bAD\b|광고|스폰서/i.test(t)) return true;
      }
    }
    // 라벨이 따로 없으면 카드 전체 텍스트로 보조 판정
    const txt = (el.textContent || "").trim();
    return /\bAD\b|광고|스폰서/i.test(txt);
  }

  // 2) 숫자문자열 비교 유틸
  function eqNumStrInner(a?: string | number | null, b?: string | number | null): boolean {
    if (a == null || b == null) return false;
    const sa = String(a).replace(/^0+/, "");
    const sb = String(b).replace(/^0+/, "");
    return sa === sb;
  }

  // 3) href에서 가능한 상품ID들 추출
  function extractIds(href: string): string[] {
    const ids: string[] = [];
    const regs = [
      /[?&](nvMid)=(\d+)/i,
      /[?&](productId)=(\d+)/i,
      /[?&](prodNo)=(\d+)/i,
      /\/products\/(\d+)/i,
      /\/product\/(\d+)/i,
    ];
    for (const r of regs) {
      const m = href.match(r);
      if (m) {
        const val = m[m.length - 1];
        if (val && /^\d+$/.test(val)) ids.push(val);
      }
    }
    return ids;
  }

  // 4) 상대링크 → 절대링크
  function abs(href: string): string {
    try { return new URL(href, location.origin).href; } catch { return href; }
  }

  // 5) "상품형 광고 카드" 판정: 광고 뱃지 + 상품ID 링크 보유
  function isProductAdCard(el: Element): boolean {
    if (!isAdBadge(el)) return false;
    const aTags = Array.from(el.querySelectorAll<HTMLAnchorElement>("a[href]"));
    return aTags.some(a => {
      const href = abs(a.getAttribute("href") || "");
      return /nvMid=|productId=|prodNo=|\/products\//i.test(href);
    });
  }

  // 6) 후보 카드 수집 (레이아웃 내성)
  const cardSelectors = [
    "div[class*='basicList_item__']",   // 리스트형
    "div[class*='product_item__']",     // 카드형
    ".list_basis li",
    ".list_basis > div",
    ".basicList_list_basis__uNBZC li",
    ".basicList_list_basis__uNBZC > div",
  ];
  let cards: Element[] = [];
  for (const sel of cardSelectors) {
    const found = Array.from(document.querySelectorAll(sel));
    if (found.length) { cards = found; break; }
  }
  if (!cards.length) cards = Array.from(document.querySelectorAll("li, div"));

  // 7) "상품형 광고 카드"만 필터
  const adCards = cards.filter(isProductAdCard);

  // 8) 스토어명/링크 추출 로직
  const storeLinkDomainRe = /(smartstore\.naver\.com|brand\.naver\.com|shopping\.naver\.com\/partner|shopping\.naver\.com\/stores)/i;
  function extractStoreInfo(adEl: Element) {
    // 우선 스토어 앵커 우선 탐색
    const aTags = Array.from(adEl.querySelectorAll<HTMLAnchorElement>("a[href]"));
    let storeName: string | undefined;
    let storeLink: string | undefined;

    // 8-1) 도메인 기반 스토어 앵커
    for (const a of aTags) {
      const href = abs(a.getAttribute("href") || "");
      if (storeLinkDomainRe.test(href)) {
        storeLink = href;
        const txt = (a.textContent || "").trim();
        if (txt) storeName = txt;
        break;
      }
    }

    // 8-2) 클래스/데이터 기반 후보 (UI 클래스 변화 대응)
    if (!storeName) {
      const nameEl =
        adEl.querySelector("[class*='mall']") ||
        adEl.querySelector("[class*='seller']") ||
        adEl.querySelector("[data-nclick*='shop']") ||
        adEl.querySelector("a[title]");
      const txt = (nameEl?.textContent || "").trim();
      if (txt) storeName = txt;
      if (!storeLink && nameEl instanceof HTMLAnchorElement) {
        storeLink = abs(nameEl.getAttribute("href") || "");
      }
    }

    // 8-3) 둘 다 못 얻으면, 최후 폴백: 첫 상품 앵커 링크를 storeLink로
    if (!storeLink) {
      for (const a of aTags) {
        const href = abs(a.getAttribute("href") || "");
        if (/nvMid=|productId=|prodNo=|\/products\//i.test(href)) {
          storeLink = href;
          break;
        }
      }
    }

    return { storeName, storeLink };
  }

  // 9) 가격 추출 (내성 강화)
  function extractPrice(adEl: Element): number | undefined {
    const candidates = [
      "[class*='price'] [class*='num']",
      "[class*='price_num']",
      "[class*='price']",
      "strong",
    ];
    for (const sel of candidates) {
      const el = adEl.querySelector(sel);
      const txt = (el?.textContent || "").replace(/[^\d]/g, "");
      if (txt) return Number(txt);
    }
    return undefined;
  }

  // 10) 페이지 내 랭킹 계산 및 타겟 매칭
  let adRankInPage = 0;
  let hit: AdSearchResult | null = null;

  for (const ad of adCards) {
    adRankInPage += 1;

    // 이 카드가 가진 모든 상품ID 후보
    const idsInCard: string[] = [];
    const anchors = Array.from(ad.querySelectorAll<HTMLAnchorElement>("a[href]"));
    for (const a of anchors) {
      const href = abs(a.getAttribute("href") || "");
      const ids = extractIds(href);
      if (ids.length) idsInCard.push(...ids);
    }

    // 타겟 매칭
    const matched = idsInCard.some((x) => eqNumStrInner(x, targetId));
    if (matched) {
      const { storeName, storeLink } = extractStoreInfo(ad);
      const price = extractPrice(ad);
      hit = { adRank: adRankInPage, storeName, storeLink, price };
      break;
    }
  }

  // adCards.length 대신 "상품형 광고 카드 수"로 누적 (정확도 개선)
  return {
    found: hit,
    totalAdsInPage: adCards.length,
    pageSize: PAGE_SIZE_IN,
  };
}, productId, PAGE_SIZE);
```

---

### 왜 이게 정확도가 올라가나

* **isProductAdCard** 로 “광고 뱃지 + 상품ID 링크 보유”를 동시에 요구합니다.
  → 브랜드/기획전/스폰서 블록처럼 **상품이 아닌 광고**를 카운트에서 제외해 누적 오차를 줄입니다.

* **storeName/storeLink** 는

  1. `smartstore|brand|partner|stores` 도메인 앵커를 1순위로,
  2. 클래스/데이터 기반 후보(`mall`, `seller`, `data-nclick*="shop"`) 2순위로,
  3. 그래도 없으면 **상품 앵커 링크를 폴백**합니다.
     → 값 누락을 거의 제거합니다.

* **totalAdsInPage** 도 “상품형 광고 카드 수”만 사용하므로, 전역 순번 누적이 안정적입니다.

---

### 점검 포인트(빠르게 확인)

1. 동일 키워드로 PC 브라우저에서 직접 SERP를 열고, **광고 배지 달린 “상품 카드”만 세어** 보세요.
   `adCards.length` 와 실제 페이지 광고 상품 개수가 일치해야 합니다.

2. 타겟 카드에서 **스토어 링크 앵커가 실제로 존재**하는지 DevTools로 확인해 보세요.
   없다면 현재 DOM이 “상품 상세(트래킹) 링크만 있고 스토어 링크는 미노출” 구조일 수 있으니, 폴백 링크가 들어오는지 확인합니다.

3. 여전히 1\~2칸 틀어지면, 그 페이지 상단/중단/하단에 **브랜드관/기획전 광고 블록**이 끼어 있는지 확인하세요.
   만약 상품 링크를 아예 안 가진 광고 블록이 광고배지를 달고 섞여 있으면, `isProductAdCard`가 잘 걸러내는지 셀렉터를 한 줄 더 보강해야 합니다.

---

필요하면 실제 페이지의 HTML 조각(해당 광고 카드 하나만) 붙여주시면, 그 구조에 맞춰 선택자를 한 번 더 튜닝해 드리겠습니다.
