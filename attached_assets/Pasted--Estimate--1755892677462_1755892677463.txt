알겠어. 아래는 **리플릿 에이전시 프롬프트**로 바로 붙여넣어 쓸 수 있게, “실시간 기준”으로만 동작하도록 **광고 평균순위(리포트/Estimate) 관련 전부 삭제**하고 다시 정리한 최종본이야.
요청하신 대로 \*\*\[1) 기술 스택 & 폴더] \[6) 프런트(UI) 요구사항] \[10) 참고 링크]\*\*는 통째로 제거했어.

---

# 리플릿 에이전시 작업 지시서 — Naver 쇼핑 실시간 순위 추적(오가닉/광고 분리)

## 0) 목표

* 입력(공통): `productId`(네이버 상품번호), `keyword`
* 출력(공통): `productId`, `storeName`, `storeLink`, `price`, `globalRank`, `page`, `rankInPage`, `found`, `notes?`
* PC 기준(1페이지 40개)로 페이지·순위 환산:

  * `page = Math.ceil(globalRank / 40)`
  * `rankInPage = ((globalRank - 1) % 40) + 1`
* 메뉴 2개로 분리:

  * **일반 제품(오가닉)**: 네이버 **검색 OpenAPI**만 사용, 200위까지(100×2회) 즉시 조회
  * **광고 제품**: **Puppeteer**로 실제 **SERP**를 페이지 단위 스캔(광고 카드만 집계) → 실시간 위치 산출
    (평균 광고순위·통계 리포트·Estimate 등 **모든 비실시간 요소는 사용하지 않음**)

---

## 2) 데이터 스키마

### 2.1 요청 DTO

```ts
type RankQuery = {
  productId: string; // 숫자 문자열
  keyword: string;
};
```

### 2.2 응답 DTO

```ts
type RankResult = {
  productId: string;
  storeName?: string;
  storeLink?: string;
  price?: number;       // KRW
  globalRank?: number;  // 1..N
  page?: number;        // 1..N (PC 40개 기준)
  rankInPage?: number;  // 1..40
  found: boolean;
  notes?: string[];
};
```

---

## 3) 오가닉(일반) 랭킹 — OpenAPI 200위 탐색

### 3.1 호출 규칙

* 엔드포인트: `GET https://openapi.naver.com/v1/search/shop.json`
* 파라미터:

  * `query=keyword`
  * `display=100`
  * `start=1` 과 `start=101` **각 1회** 총 2회(200개)
* 응답 필드 사용:

  * `items[].productId`, `items[].mallName`, `items[].link`, `items[].lprice`

### 3.2 알고리즘

1. `start=1` 과 `start=101`로 각각 호출해 `items`를 합침(최대 200개).
2. `String(item.productId) === String(input.productId)`로 전역 인덱스 탐색(0-based → 1-based).
3. 찾으면 전역순위→페이지/페이지내 순위를 환산, 상점/링크/가격 매핑.
4. 없으면 `found=false`, `notes=["상위 200위 내 미노출"]`.

### 3.3 샘플 구현

```ts
// server/naverOrganic.ts
import fetch from "node-fetch";

const OPENAPI = "https://openapi.naver.com/v1/search/shop.json";

export async function fetchOrganicRank({
  keyword,
  productId,
  clientId,
  clientSecret,
}: {
  keyword: string;
  productId: string;
  clientId: string;
  clientSecret: string;
}) {
  async function call(start: number) {
    const url = `${OPENAPI}?query=${encodeURIComponent(keyword)}&display=100&start=${start}`;
    const res = await fetch(url, {
      headers: {
        "X-Naver-Client-Id": clientId,
        "X-Naver-Client-Secret": clientSecret,
      },
    });
    if (!res.ok) throw new Error(`OpenAPI ${res.status}: ${await res.text()}`);
    return res.json();
  }

  const [a, b] = await Promise.all([call(1), call(101)]);
  const items = [...(a.items ?? []), ...(b.items ?? [])];

  const idx = items.findIndex((it: any) => String(it.productId) === String(productId));
  if (idx === -1) {
    return { productId, found: false, notes: ["상위 200위 내 미노출"] } as const;
  }

  const hit = items[idx];
  const globalRank = idx + 1;
  const page = Math.ceil(globalRank / 40);
  const rankInPage = ((globalRank - 1) % 40) + 1;

  return {
    productId,
    storeName: hit.mallName,
    storeLink: hit.link,
    price: Number(hit.lprice),
    globalRank,
    page,
    rankInPage,
    found: true,
  } as const;
}
```

---

## 4) 광고(유료) 랭킹 — Puppeteer로 실시간 SERP 스캔

### 4.1 핵심 원칙

* **실시간 SERP만** 사용(보고서/추정값 불사용).
* PC 고정: UA/뷰포트/언어를 PC 한국 사용자에 맞춰 설정.
* `pagingIndex=1..N`, `pagingSize=40` 기준으로 페이지를 순차 탐색.
* **광고 카드만** 선별해 누적 순번을 계산(오가닉과 분리된 광고 전용 globalRank).

### 4.2 안정화(차단 회피) 가이드

* 페이지 간 **랜덤 지연(1200–2500ms)**, 각 페이지에서 **자연스크롤** 1–2회.
* `networkidle2` 대기 + 결과 컨테이너 등장 대기.
* 세션 쿠키 유지, 동시성 1(직렬).
* 에러 시 한 번 재시도 후 포기.

### 4.3 선택자 전략(권장)

* 결과 리스트 루트: `.list_basis` 또는 유사 컨테이너(실제 DOM은 수시 변경 가능 → **필수: 개발 시점에 재검증**).
* **광고 카드 판단**: 카드 내부에 **‘AD’/‘쇼핑광고’/‘스폰서’** 등의 라벨 텍스트가 있는지 검사.
  예) 라벨 셀렉터 후보: `span[class*="ad"]`, `em[class*="ad"]`, `[data-ad*="true"]`, `[class*="sponsor"]` 등 → 텍스트 포함 여부로 최종 결정.
* **상품 ID 추출**:

  * 카드 내부 앵커의 `href`에서 `nvMid=|productId=|prodNo=` 등의 파라미터 탐색(정규식 2\~3개 준비).
  * 없으면 `data-` 속성, 혹은 카드 내 링크들의 쿼리스트링을 전수 검사.

### 4.4 샘플 구현

```ts
// server/adCrawler.ts
import puppeteer from "puppeteer";

function extractProductIdFromHref(href: string): string | null {
  // 대표 패턴 몇 개 지원
  const regs = [
    /(?:[?&])(nvMid|productId|prodNo)=(\d+)/i,
    /\/products\/(\d+)/i,
  ];
  for (const r of regs) {
    const m = href.match(r);
    if (m) return m[m.length - 1];
  }
  return null;
}

export async function fetchAdRank({
  keyword,
  productId,
  maxPages = 10,
}: {
  keyword: string;
  productId: string;
  maxPages?: number;
}) {
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  });
  try {
    const page = await browser.newPage();

    await page.setUserAgent(
      // Windows Chrome 최신 계열 UA
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    );
    await page.setViewport({ width: 1366, height: 768, deviceScaleFactor: 1 });
    await page.setExtraHTTPHeaders({ "Accept-Language": "ko-KR,ko;q=0.9" });

    let adSeen = 0;

    for (let i = 1; i <= maxPages; i++) {
      const url =
        `https://search.shopping.naver.com/search/all?` +
        `adQuery=${encodeURIComponent(keyword)}&pagingIndex=${i}&pagingSize=40&viewType=list`;
      await page.goto(url, { waitUntil: "networkidle2", timeout: 60_000 });

      // 결과 컨테이너 대기(필요 시 셀렉터 변경)
      await page.waitForSelector(".list_basis", { timeout: 15_000 }).catch(() => {});

      // 자연 스크롤 1~2회
      await page.evaluate(async () => {
        await new Promise<void>((resolve) => {
          let h = 0, step = 0;
          const timer = setInterval(() => {
            window.scrollBy(0, 400);
            h += 400;
            step++;
            if (h > 2000 || step > 8) { clearInterval(timer); resolve(); }
          }, 150);
        });
      });

      // 광고 카드 스캔
      const found = await page.evaluate((targetId: string) => {
        function isAdCard(el: Element): boolean {
          // 라벨 텍스트 기반 판정(필요 시 보강)
          const label = el.querySelector('span,em,i,[class*="ad"],[class*="sponsor"]');
          const txt = (label?.textContent ?? "").trim();
          if (!txt) {
            // 라벨이 분리된 구조면 카드 내에 ‘광고’ 문구가 존재하는지 검사
            const hasAdText = /\bAD\b|광고|스폰서/i.test(el.textContent ?? "");
            if (!hasAdText) return false;
          } else {
            if (!/\bAD\b|광고|스폰서/i.test(txt)) return false;
          }
          return true;
        }

        // 카드 후보 수집(필요 시 셀렉터 보강)
        const cards = Array.from(document.querySelectorAll(".list_basis li, .list_basis div[class*=list__item]"));

        let adRank = 0;
        for (const card of cards) {
          if (!isAdCard(card)) continue;

          adRank += 1;

          // 링크들에서 productId 추출
          const links = Array.from(card.querySelectorAll<HTMLAnchorElement>("a[href]"));
          for (const a of links) {
            const href = a.getAttribute("href") || "";
            const regs = [
              /(?:[?&])(nvMid|productId|prodNo)=(\d+)/i,
              /\/products\/(\d+)/i,
            ];
            let pid: string | null = null;
            for (const r of regs) {
              const m = href.match(r);
              if (m) { pid = m[m.length - 1]; break; }
            }
            if (pid && String(pid) === String(targetId)) {
              const storeName =
                (card.querySelector("[class*='mall']")?.textContent || "").trim() ||
                (card.querySelector("[data-nclick*='shop']")?.textContent || "").trim() ||
                undefined;

              const link = a.href;
              const priceTxt =
                (card.querySelector("[class*='price']")?.textContent || "")
                  .replace(/[^\d]/g, "");
              const price = priceTxt ? Number(priceTxt) : undefined;

              return {
                adRank,
                storeName,
                storeLink: link,
                price,
              };
            }
          }
        }
        return null;
      }, productId);

      if (found) {
        const globalRank = found.adRank;
        const pageNo = Math.ceil(globalRank / 40);
        const rankInPage = ((globalRank - 1) % 40) + 1;
        return {
          productId,
          storeName: found.storeName,
          storeLink: found.storeLink,
          price: found.price,
          globalRank,
          page: pageNo,
          rankInPage,
          found: true,
        } as const;
      }

      // 누적 광고 개수 추적(선택): 다음 페이지로 넘어가기 전에 현재 페이지 광고 수 세기
      adSeen += await page.evaluate(() => {
        function isAdCard(el: Element): boolean {
          const label = el.querySelector('span,em,i,[class*="ad"],[class*="sponsor"]');
          const txt = (label?.textContent ?? "").trim();
          if (!txt) {
            const hasAdText = /\bAD\b|광고|스폰서/i.test(el.textContent ?? "");
            if (!hasAdText) return false;
          } else {
            if (!/\bAD\b|광고|스폰서/i.test(txt)) return false;
          }
          return true;
        }
        const cards = Array.from(document.querySelectorAll(".list_basis li, .list_basis div[class*=list__item]"));
        return cards.filter(isAdCard).length;
      });

      // 랜덤 지연
      await page.waitForTimeout(1200 + Math.floor(Math.random() * 1300));
    }

    return { productId, found: false, notes: ["광고 결과 내 미노출(스캔 한계 도달)"] } as const;
  } finally {
    await browser.close().catch(() => {});
  }
}
```

---

## 5) Express API 설계

### 5.1 라우트

* `POST /api/rank/organic` → Body: `RankQuery` → 응답: `RankResult`
* `POST /api/rank/ad` → Body: `RankQuery` → 응답: `RankResult` (광고 전용 순번)

### 5.2 샘플 서버 엔트리

```ts
// server/index.ts
import express from "express";
import { fetchOrganicRank } from "./naverOrganic";
import { fetchAdRank } from "./adCrawler";

const app = express();
app.use(express.json());

app.post("/api/rank/organic", async (req, res) => {
  try {
    const { productId, keyword } = req.body;
    if (!productId || !keyword) return res.status(400).json({ message: "productId, keyword 필요" });

    const data = await fetchOrganicRank({
      productId,
      keyword,
      clientId: process.env.NAVER_OPENAPI_CLIENT_ID!,
      clientSecret: process.env.NAVER_OPENAPI_CLIENT_SECRET!,
    });
    res.json(data);
  } catch (e: any) {
    res.status(500).json({ message: e.message });
  }
});

app.post("/api/rank/ad", async (req, res) => {
  try {
    const { productId, keyword, maxPages } = req.body;
    if (!productId || !keyword) return res.status(400).json({ message: "productId, keyword 필요" });

    const data = await fetchAdRank({ productId, keyword, maxPages: Number(maxPages) || 10 });
    res.json(data);
  } catch (e: any) {
    res.status(500).json({ message: e.message });
  }
});

app.get("/api/_health", (_, res) => res.json({ ok: true, service: "naver-rank" }));

app.listen(process.env.PORT || 3000, () => {
  console.log("server started");
});
```

---

## 7) 검증 시나리오

### 7.1 오가닉

* 키워드 입력 → OpenAPI 2회 호출(1..100, 101..200) → 대상 `productId`가 포함되면:

  * `globalRank`, `page`, `rankInPage` 일관 계산
  * `storeName=mallName`, `storeLink=link`, `price=lprice`
* 미포함 시 `found=false`, `notes=["상위 200위 내 미노출"]`.

### 7.2 광고

* 키워드 입력 → Puppeteer가 `pagingIndex=1..N` 순회(최대 10페이지 기본) → 광고 카드만 누적:

  * 대상 `productId`가 등장하면 해당 시점 누적 순번을 `globalRank`로 저장 → 페이지 환산
  * 없으면 `found=false`, `notes=["광고 결과 내 미노출(스캔 한계 도달)"]`.

---

## 8) 에러/예외 처리

* OpenAPI:

  * `429/403`: 응답 본문 메시지 그대로 노출 + 사용자에게 “잠시 후 재시도” 안내.
  * JSON 파싱 실패: 원문 텍스트 포함해 500 반환.
* Puppeteer:

  * 셀렉터 미일치/레이아웃 변경: `notes`에 “셀렉터 재검증 필요” 표기.
  * `TimeoutError`: 한 번 재시도, 재시도 실패 시 `found=false`로 종료.
  * 브라우저 리소스 누수 방지: `finally { browser.close() }` 보장.
* 입력 검증:

  * `productId`는 숫자 문자열만 허용, `keyword`는 공백 불가.

---

## 9) 보안/운영 주의

* 오가닉은 **공식 OpenAPI만 사용**(프런트 HTML 파싱 금지) → 안정성/호환성 확보.
* 광고는 **실시간 SERP**를 크롤링하므로 **선량한 요청 속도** 유지, **동시성 1** 권장.
* PC 기준 40개/페이지 환산은 네이버 쇼핑 UI 전제를 따른다(프로덕션에서 변경 감지 시 상수 업데이트).
* 크롤링 차단 리스크에 대비해:

  * IP 고정/빈번한 요청 회피, **랜덤 지연**·**자연 스크롤** 필수.
  * 셀렉터는 배포 직전 실제 DOM 기준으로 재검증하고, 코드 내 주석으로 근거를 명시.

---

필요하면 이 지시서 그대로 **서버 코드 통째로** 뽑아줄게(리플릿용 `package.json`, `tsconfig`, PM2 스크립트까지 포함).
