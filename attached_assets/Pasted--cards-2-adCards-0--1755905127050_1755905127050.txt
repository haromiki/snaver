문제 상황은 “막힌 것”이라기보다 **봇 감지→실컨텐츠 미렌더** 상태에 가깝습니다.
로그에서 `cards=2, adCards=0`이 모든 페이지에서 반복되는 건, 실제 리스트가 안 뜨고 **껍데기 DOM만 보였다는 신호**예요. (정상이라면 앵커가 수십 개 잡혀야 합니다.)

아래처럼 **처음부터 다시** 짭니다:

1. **봇 우회(stealth) + 한글/타임존/플러그인 속성 스푸핑**
2. **로딩 보증 로직**: “상품 앵커가 충분히 로드될 때까지” 대기
3. **광고 판정 & ID 매칭**: 광고배지+상품링크 동시 조건
4. **네트워크 스니핑 폴백**: XHR/Fetch JSON에서 상품ID가 등장하는지 확인(디버깅·대체 경로)
5. **디버그 정보**를 상세 반환 (왜 못 잡았는지 바로 알 수 있게)

아래 코드는 **그대로 교체**해서 쓰면 됩니다. (패키지 1개 추가 필요)

---

## 0) 설치 (추가 1개)

`puppeteer-extra` + `stealth` 플러그인

```bash
npm i puppeteer-extra puppeteer-extra-plugin-stealth
```

---

## 1) 광고 순위 검색 — 안정판 (드롭인 교체)

```ts
// server/adRankStealth.ts
import type { RankResult } from "@shared/schema";
import StealthPlugin from "puppeteer-extra-plugin-stealth";
import puppeteerExtra from "puppeteer-extra";
import type { Browser } from "puppeteer";

type AdSearchResult = {
  adRank: number;       // 페이지 내 광고 순번(1-based)
  storeName?: string;
  storeLink?: string;
  price?: number;
};

const PAGE_SIZE = 40;

// 숫자문자열 동일성(선행 0 제거)
function eqNumStr(a?: string | number | null, b?: string | number | null): boolean {
  if (a == null || b == null) return false;
  const sa = String(a).replace(/^0+/, "");
  const sb = String(b).replace(/^0+/, "");
  return sa === sb;
}

export async function fetchAdRank({
  keyword,
  productId,
  maxPages = 6,
  headful = false,            // 로컬 디버깅 시 true 추천
  proxy,                      // { server:"http://ip:port", username?:string, password?:string }
}: {
  keyword: string;
  productId: string; // nvMid / productId / prodNo / /products/{id} 모두 허용
  maxPages?: number;
  headful?: boolean;
  proxy?: { server: string; username?: string; password?: string };
}): Promise<RankResult> {
  let browser: Browser | null = null;

  try {
    // 1) Stealth + UA/타임존/플러그인 속성 스푸핑
    puppeteerExtra.use(StealthPlugin());

    const launchArgs = [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--disable-web-security",
      "--disable-extensions",
      "--lang=ko-KR,ko",                            // 언어
      "--disable-blink-features=AutomationControlled", // webdriver 흔적 제거
    ];
    if (proxy?.server) launchArgs.push(`--proxy-server=${proxy.server}`);

    browser = await puppeteerExtra.launch({
      headless: headful ? false : "new",
      args: launchArgs,
      // executablePath: "/usr/bin/google-chrome-stable", // 필요 시 지정
    });

    const page = await browser.newPage();

    // 프록시 인증
    if (proxy?.username && proxy?.password) {
      await page.authenticate({ username: proxy.username, password: proxy.password });
    }

    // 기본 환경 스푸핑
    await page.setUserAgent(
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
    );
    await page.setViewport({ width: 1364 + Math.floor(Math.random()*3), height: 768, deviceScaleFactor: 1 });
    await page.setExtraHTTPHeaders({ "Accept-Language": "ko-KR,ko;q=0.9" });
    await page.emulateTimezone("Asia/Seoul");

    // webdriver 흔적 추가 제거
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, "webdriver", { get: () => false });
      Object.defineProperty(navigator, "platform", { get: () => "Win32" });
      Object.defineProperty(navigator, "languages", { get: () => ["ko-KR", "ko"] });
      // plugins length > 0
      // @ts-ignore
      Object.defineProperty(navigator, "plugins", { get: () => [1, 2, 3, 4, 5] });
    });

    // 2) 네트워크 스니핑(디버그 & 폴백)
    const sniff: { url: string; hasProductId: boolean }[] = [];
    page.on("response", async (res) => {
      try {
        const url = res.url();
        const type = res.request().resourceType();
        if (!(type === "xhr" || type === "fetch")) return;
        const headers = res.headers();
        const ct = (headers["content-type"] || headers["Content-Type"] || "").toString();
        if (!ct.includes("application/json")) return;
        const text = await res.text();
        const hasProductId = text.includes(productId);
        if (hasProductId || /shopping\.naver\.com\/api/i.test(url)) {
          sniff.push({ url, hasProductId });
        }
      } catch {}
    });

    let cumulativeAdCount = 0;

    for (let pageIndex = 1; pageIndex <= maxPages; pageIndex++) {
      const url =
        `https://search.shopping.naver.com/search/all?` +
        `query=${encodeURIComponent(keyword)}&` +
        `adQuery=${encodeURIComponent(keyword)}&` +
        `productSet=total&sort=rel&` +
        `pagingIndex=${pageIndex}&` +
        `pagingSize=${PAGE_SIZE}&` +
        `viewType=list`;

      await page.goto(url, { waitUntil: "domcontentloaded", timeout: 60_000 });

      // 3) 로딩 보증: 상품 앵커가 충분히 나올 때까지
      await page.waitForFunction(() => {
        const sel = 'a[href*="nvMid="],a[href*="productId="],a[href*="prodNo="],a[href*="/products/"],a[href*="/product/"]';
        return document.querySelectorAll(sel).length >= 8;
      }, { timeout: 12_000 }).catch(() => { /* 계속 진행 */ });

      // 자연 스크롤로 lazy-load 유도
      await page.evaluate(async () => {
        await new Promise<void>((resolve) => {
          let h = 0, step = 0;
          const timer = setInterval(() => {
            window.scrollBy(0, 600);
            h += 600; step++;
            if (h > 2400 || step > 8) { clearInterval(timer); resolve(); }
          }, 120);
        });
      });

      // UI가 여전히 비어있으면 하드 리로드(봇 미스일 때)
      const anchorCount = await page.evaluate(() => {
        const sel = 'a[href*="nvMid="],a[href*="productId="],a[href*="prodNo="],a[href*="/products/"],a[href*="/product/"]';
        return document.querySelectorAll(sel).length;
      });
      if (anchorCount < 3) {
        await page.reload({ waitUntil: "domcontentloaded" }).catch(() => {});
        await page.waitForTimeout(1500);
      }

      // 4) 광고 스캔 (광고배지 + 상품링크 동시 보유)
      const pageResult = await page.evaluate((targetId: string) => {
        function abs(h: string){ try { return new URL(h, location.origin).href; } catch { return h; } }
        function eq(a?: any,b?: any){ if(a==null||b==null) return false; return String(a).replace(/^0+/,"")===String(b).replace(/^0+/,""); }
        function idsFrom(href: string){
          const out: string[] = [];
          const regs = [
            /[?&](nvMid)=(\d+)/i,
            /[?&](productId)=(\d+)/i,
            /[?&](prodNo)=(\d+)/i,
            /\/products\/(\d+)/i,
            /\/product\/(\d+)/i,
          ];
          for (const r of regs) {
            const m = href.match(r);
            if (m) {
              const v = m[m.length-1];
              if (v && /^\d+$/.test(v)) out.push(v);
            }
          }
          return out;
        }

        // 광고 라벨 판정(aria-label/title/텍스트/클래스)
        function hasAdMark(el: Element): boolean {
          const aria=(el.getAttribute("aria-label")||"") + " " + (el.getAttribute("title")||"");
          if (/\bAD\b|광고|스폰서/i.test(aria)) return true;
          const txt=(el.textContent||"").trim();
          if (/\bAD\b|광고|스폰서/i.test(txt)) return true;
          const cls=(el.className||"").toString();
          if (/(^|[_-])ad([_-]|$)/i.test(cls) && !/address|adapter|load|shadow/i.test(cls)) return true;
          // 카드 내부 마커
          const mk = el.querySelector('[aria-label*="광고"],[title*="광고"],[class*="ad"],[data-ad],[data-advert]');
          if (mk) return true;
          return false;
        }

        const root = document.querySelector("#content") || document.body;
        const candidateSelectors = [
          "div[class*='basicList_item__']",
          "div[class*='product_item__']",
          ".list_basis li", ".list_basis > div",
          ".basicList_list_basis__uNBZC li", ".basicList_list_basis__uNBZC > div",
        ];
        let cards: Element[] = [];
        for (const sel of candidateSelectors) {
          const found = Array.from(root.querySelectorAll(sel));
          if (found.length) { cards = found; break; }
        }
        if (!cards.length) {
          const aSel='a[href*="nvMid="],a[href*="productId="],a[href*="prodNo="],a[href*="/products/"],a[href*="/product/"]';
          const anchors = Array.from(root.querySelectorAll<HTMLAnchorElement>(aSel));
          const box = new Set<Element>();
          for (const a of anchors) {
            const host = a.closest("li, div, article, section");
            if (host) box.add(host);
          }
          cards = Array.from(box);
        }

        // "상품형 광고"만: 광고라벨 + 상품링크
        const adCards = cards.filter(el => {
          if (!hasAdMark(el)) return false;
          const links = Array.from(el.querySelectorAll<HTMLAnchorElement>("a[href]"));
          return links.some(a => /nvMid=|productId=|prodNo=|\/products\/|\/product\//i.test(abs(a.getAttribute("href")||"")));
        });

        let adRankInPage = 0;
        let hit: AdSearchResult | null = null;
        const idsPreview: Array<{rank:number, ids:string[]}> = [];

        for (const el of adCards) {
          adRankInPage += 1;

          const links = Array.from(el.querySelectorAll<HTMLAnchorElement>("a[href]"));
          const ids: string[] = [];
          for (const a of links) idsFrom(abs(a.getAttribute("href")||"")).forEach(v => ids.push(v));
          idsPreview.push({ rank: adRankInPage, ids: ids.slice(0, 5) });

          if (ids.some(v => eq(v, targetId))) {
            // 스토어 정보
            const storeDomain=/(smartstore\.naver\.com|brand\.naver\.com|shopping\.naver\.com\/(partner|stores))/i;
            let storeName: string | undefined, storeLink: string | undefined;
            for (const a of links) {
              const href=abs(a.getAttribute("href")||"");
              if (storeDomain.test(href)) {
                storeLink = href;
                const t=(a.textContent || a.getAttribute("aria-label") || a.getAttribute("title") || "").trim();
                if (t) storeName=t;
                break;
              }
            }
            if (!storeName) {
              const n = el.querySelector<HTMLElement>("[class*='mall'],[class*='seller'],[data-nclick*='shop'],a[title]");
              if (n) {
                const t=(n.textContent || n.getAttribute("aria-label") || n.getAttribute("title") || "").trim();
                if (t) storeName=t;
                if (!storeLink && n instanceof HTMLAnchorElement) storeLink=abs(n.getAttribute("href")||"");
              }
            }
            if (!storeLink) {
              const prodA = links.find(a => /nvMid=|productId=|prodNo=|\/products\/|\/product\//i.test(abs(a.getAttribute("href")||"")));
              if (prodA) storeLink = abs(prodA.getAttribute("href")||"");
            }

            // 가격
            const priceSel=["[class*='price'] [class*='num']","[class*='price_num']","[class*='price']","strong"];
            let price: number | undefined;
            for (const s of priceSel) {
              const elp = el.querySelector<HTMLElement>(s);
              const n = (elp?.textContent || "").replace(/[^\d]/g,"");
              if (n) { price = Number(n); break; }
            }

            hit = { adRank: adRankInPage, storeName, storeLink, price };
            break;
          }
        }

        return {
          found: hit,
          totalCards: cards.length,
          totalAdsInPage: adCards.length,
          idsPreview: idsPreview.slice(0, 6),
          webdriver: (navigator as any).webdriver,
        };
      }, productId);

      console.log(`[AD][p${pageIndex}] cards=${pageResult.totalCards} adCards=${pageResult.totalAdsInPage} webdriver=${pageResult.webdriver} idsPreview=${JSON.stringify(pageResult.idsPreview)}`);

      if (pageResult.found) {
        const r = pageResult.found as AdSearchResult;
        const pageNo = pageIndex;                        // 현재 SERP 페이지
        const rankInPage = r.adRank;                     // 그 페이지 내 광고 순번
        const globalRank = cumulativeAdCount + r.adRank; // 이전 페이지 광고 누적 + 현재

        return {
          productId,
          storeName: r.storeName,
          storeLink: r.storeLink,
          price: r.price,
          globalRank,
          page: pageNo,
          rankInPage,
          found: true,
        };
      }

      // 누적
      cumulativeAdCount += (pageResult.totalAdsInPage || 0);

      // 페이지 간 지연
      await page.waitForTimeout(1000 + Math.floor(Math.random() * 700));
    }

    // 폴백 디버그: 네트워크 스니핑 중 해당 productId 등장 여부
    const hinted = sniff.filter(s => s.hasProductId);
    if (hinted.length) {
      return {
        productId,
        found: false,
        notes: [
          `DOM 미검출. 네트워크 응답에 productId 등장(${hinted.length}건)`,
          ...hinted.slice(0,3).map(h => `hit: ${h.url}`)
        ],
      };
    }

    return {
      productId,
      found: false,
      notes: [`광고 결과 내 미노출(${maxPages}페이지 스캔 완료 또는 컨텐츠 미렌더)`],
    };
  } catch (err: any) {
    return { productId, found: false, notes: [`크롤링 오류: ${err?.message || String(err)}`] };
  } finally {
    try { await browser?.close(); } catch {}
  }
}
```

---

## 2) 왜 이 설계가 필요한가

* **봇 감지**가 들어오면 컨텐츠가 거의 안 뜹니다(당신 로그의 cards=2). → Stealth + 속성 스푸핑, 타임존/언어/플러그인 조정이 필수.
* **로딩 보증**을 “네트워크 idle”이 아닌 **“상품 앵커가 N개 이상”** 기준으로 바꿔야 실데이터가 준비됐는지 판별됩니다.
* 광고 판정은 **라벨 + 상품링크** 동시 조건으로 오탐을 줄였습니다.
* 그래도 DOM이 비면 **네트워크 스니핑**으로 productId가 응답에 나오는지라도 확인할 수 있습니다(운영 중 디버깅에 매우 유용).

---

## 3) 빠른 체크리스트

* [ ] 위 코드로 교체 후, 요청 바디에 `maxPages: 6` 이상 주기
* [ ] 서버 로그에서 `webdriver=false` 인지 확인 (true면 봇 감지됨)
* [ ] 각 페이지 `cards, adCards, idsPreview` 값이 자연스러운지
* [ ] 여전히 `cards`가 극소(=2)면 **프록시(거주형 IP)** 도입을 고려 (반복 트래픽·데이터센터 IP는 민감)

---

원하면 **OpenAPI(오가닉) + 이 Stealth 광고 스캐너**를 하나의 서비스로 묶고, 결과 JSON에 `debug` 필드를 남기도록 정리해 드릴게요.
